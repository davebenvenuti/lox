package com.craftinginterpreters.tool

import java.io.PrintWriter

object GenerateAst {
    @JvmStatic
    fun main(args: Array<String>) {
        if(args.size != 1) {
            System.err.println("Usage: generate_ast <output directory>")
            System.exit(64)
        }

        val outputDir = args[0]

        defineAst(outputDir, "Expr", listOf(
                                         "Assign   : Token name, Expr value",
                                         "Binary   : Expr left, Token operator, Expr right",
                                         "Grouping : Expr expression",
                                         "Literal  : Any? value",
                                         "Unary    : Token operator, Expr right",
                                         "Variable : Token name",
                                     ))

        defineAst(outputDir, "Stmt", listOf(
                                         "Block      : List<Stmt> statements",
                                         "Expression : Expr expression",
                                         "Print      : Expr expression",
                                         // Couldn't use Var since that's a reserved word in Kotlin
                                         "Var        : Token name, Expr initializer",
                                     ))
    }

    private fun defineAst(outputDir: String, baseName: String, types: List<String>) {
        val path = "$outputDir/${baseName}.kt"

        PrintWriter(path, "UTF-8").use { writer ->
            writer.println("package com.craftinginterpreters.lox")
            writer.println()
            writer.println("// THIS FILE IS AUTOGENERATED BY generate-ast, DO NOT EDIT!")
            writer.println()
            writer.println("sealed class $baseName {")

            defineVisitor(writer, baseName, types)

            // AST classes
            for(type in types) {
                val (name, fields) = type.split(":").map { it.trim() }
                defineType(writer, baseName, name, fields)
            }

            writer.println()
            writer.println("    abstract fun <R> accept(visitor: Visitor<R>): R")

            writer.println("}")
        }
    }

    private fun defineType(writer: PrintWriter, baseName: String, name: String, fieldList: String) {
        val fields = fieldList.split(",").map { typeAndName ->
            val (type, name) = typeAndName.trim().split(" ", limit = 2)

            if(name == "var") {
                "val v : $type"
            } else {
                "val $name : $type"
            }
        }

        writer.println("""
                           |data class $name(
                           |    ${fields.joinToString(",\n|    ")}
                           |) : $baseName() {
                           |    override fun <R> accept(visitor: Visitor<R>): R {
                           |        return visitor.visit$name$baseName(this)
                           |    }
                           |}

                       """.trimMargin().prependIndent("    "))
    }

    private fun defineVisitor(writer: PrintWriter, baseName: String, types: List<String>) {
        writer.println("|interface Visitor<R> {".trimMargin().prependIndent("    "))

        types.map {
            var varName = it.split(":")[0].trim().lowercase()

            if (varName == "var") {
                varName = "v" // Avoid using 'var' as a variable name
            }

            var typeName = it.split(":")[0].trim()

            writer.println("        fun visit$typeName$baseName($varName: $typeName): R")
        }


        writer.println("}".trimMargin().prependIndent("    "))
        writer.println()
    }
}
